### ۱. هدف فاز سوم

در این فاز هدف ما مدل‌سازی تیم تولید هر پادکست است. تیم تولید به صورت یک درخت سلسله‌مراتبی نمایش داده می‌شود که:

* هر عضو می‌تواند چند زیردست داشته باشد.
* قابلیت اضافه کردن عضو جدید، حذف عضو و جستجوی یک فرد خاص وجود دارد.
* نمایش ساختار تیم باید خوانا و مطابق خروجی نمونه باشد.

این فاز باعث می‌شود کاربران و مدیران پلتفرم بتوانند ساختار تیم را مدیریت و مسیر ارتباط بین اعضا را مشاهده کنند.

---

### ۲. فایل‌ها و نقش آن‌ها

۱. **TeamMember.java**

* نماینده هر عضو تیم است.
* فیلدها:

  * `name`: نام عضو
  * `firstChild`: اشاره‌گر به اولین زیردست
  * `nextSibling`: اشاره‌گر به عضو هم‌سطح بعدی
* این فایل فقط داده‌ها را نگهداری می‌کند و هیچ منطق عملیاتی ندارد.

۲. **TeamTree.java**

* کلاس اصلی مدیریت درخت تیم.
* وظایف:

  * اضافه کردن عضو جدید (`insert`)
  * حذف عضو و کل زیر درختش (`delete`)
  * جستجو با الگوریتم DFS (`searchDFS`)
  * جستجو با الگوریتم BFS (`searchBFS`)
  * نمایش ساختار تیم (`display`)
* منطق اصلی همه عملیات در این کلاس قرار دارد.
* استفاده از ساختار **First Child / Next Sibling** باعث می‌شود که هر عضو بتواند چند زیردست داشته باشد و پیاده‌سازی ساده و بدون آرایه یا لیست آماده باشد.

۳. **Phase3Main.java**

* کلاس اجرای برنامه و دریافت ورودی از کاربر.
* وظایف:

  * خواندن دستورات از ورودی استاندارد (بدون هاردکد)
  * تشخیص نوع دستور و فراخوانی متد مناسب از `TeamTree`
  * چاپ خروجی مطابق نمونه
* دستورات پشتیبانی شده:

  * `insert <name>` : اضافه کردن ریشه
  * `insert <parent> <child>` : اضافه کردن عضو به زیر درخت والد
  * `display` : نمایش ساختار تیم
  * `search BFS <name>` : جستجوی عضو با الگوریتم BFS
  * `search DFS <name>` : جستجوی عضو با الگوریتم DFS
  * `delete <name>` : حذف عضو و زیر درختش

---

### ۳. منطق و نحوه کارکرد کدها

۱. **Insert**

* اگر والد وجود داشته باشد، عضو جدید به انتهای فرزندان والد اضافه می‌شود.
* اگر والد وجود نداشته باشد، پیام خطا نمایش داده می‌شود: `"Parent <name> does not exist"`
* اگر فقط یک اسم وارد شود و درخت خالی باشد، آن عضو به عنوان ریشه قرار می‌گیرد.

1. **Display**

   * نمایش هر عضو و فرزندان مستقیم آن به شکل:

     ```
     Parent: Child1,Child2,Child3
     ```

   * ترتیب نمایش از بالا به پایین است (ریشه به برگ‌ها).

2. **Search**

   * **DFS**: مسیر از ریشه تا عضو مورد نظر با الگوریتم Depth-First Search پیدا می‌شود و چاپ می‌شود.
   * **BFS**: مسیر از ریشه تا عضو مورد نظر با الگوریتم Breadth-First Search پیدا می‌شود و چاپ می‌شود.
   * اگر عضو وجود نداشته باشد، پیام: `"Node <name> NOT found"` نمایش داده می‌شود.

3. **Delete**

   * حذف عضو و کل زیر درخت آن.
   * پیام تایید حذف: `"Node <name> and its subtree deleted"` چاپ می‌شود.
   * پس از حذف، در دستور display عضو و تمام فرزندانش دیگر دیده نمی‌شوند.

---

### ۴. ورودی و خروجی نمونه

**ورودی نمونه:**

```
insert Producer
insert Producer Editor
insert Producer Host
insert Producer SoundEngineer
insert Editor ScriptWriter
insert SoundEngineer Intern1
insert SoundEngineer Intern2
insert Manager Assistant
display
search BFS Intern2
search DFS ScriptWriter
search BFS Manager
delete SoundEngineer
display
```

**خروجی نمونه:**

```
Parent Manager does not exist
Producer: Editor,Host,SoundEngineer
Editor: ScriptWriter
Host:
SoundEngineer: Intern1,Intern2
ScriptWriter:
Intern1:
Intern2:
Path (BFS): Producer -> SoundEngineer -> Intern2
Path (DFS): Producer -> Editor -> ScriptWriter
Node Manager NOT found
Node SoundEngineer and its subtree deleted
Producer: Editor,Host
Editor: ScriptWriter
Host:
ScriptWriter:
```

---

### ۵. نکات مهم طراحی

* استفاده از ساختار **First Child / Next Sibling** برای درخت چندفرزندی.
* تمام عملیات بدون استفاده از آرایه یا لیست آماده انجام می‌شود.
* ورودی از کاربر گرفته می‌شود و برنامه کاملاً داینامیک است.
* خروجی‌ها مطابق نمونه و خوانا هستند.
* طراحی به گونه‌ای است که افزودن، حذف یا جستجو به راحتی قابل توسعه است.

---

### ۶. نتیجه‌گیری

با فاز سوم:

* تیم تولید هر پادکست با درخت سلسله‌مراتبی مدل شد.
* جستجوی اعضا با BFS و DFS امکان‌پذیر است.
* حذف عضو کل زیر‌درخت را پاک می‌کند.
* نمایش تیم دقیق و قابل فهم است.
* ورودی و خروجی مطابق نمونه پروژه است.

تمام نیازمندی‌های فاز سوم پیاده‌سازی شده و آماده تست با ورودی دلخواه کاربر است.
