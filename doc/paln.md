
# EchoVerse – Plan اجرایی پروژه

## پروژه دوم ساختمان داده

---

## 1. هدف این سند

این سند، **برنامه اجرایی جامع (Execution Plan)** پروژه EchoVerse است و مشخص می‌کند:

- پروژه به چه فازهایی تقسیم می‌شود
- در هر فاز چه فایل‌هایی باید ساخته شوند
- نقش و مسئولیت هر فایل چیست
- چه کلاس‌ها و چه متدهایی (در سطح طراحی، نه کدنویسی) مورد نیاز هستند
- ترتیب صحیح انجام کارها چگونه است

این سند **راهنمای اصلی تیم در طول اجرای پروژه** است.

---

## 2. ساختار کلی پوشه‌ها (Project Structure)

```text
EchoVerse/
│
├── docs/
│   ├── prd.md
│   ├── plan.md
│   └── پروژه دوم ساختمان داده.md
│
├── src/
│   ├── phase1_avl/
│   │   ├── AVLNode.java
│   │   ├── AVLTree.java
│   │   └── Phase1Main.java
│   │
│   ├── phase2_graph/
│   │   ├── Graph.java
│   │   ├── Vertex.java
│   │   ├── Edge.java
│   │   ├── Dijkstra.java
│   │   └── Phase2Main.java
│   │
│   ├── phase3_team_tree/
│   │   ├── TeamMember.java
│   │   ├── TeamTree.java
│   │   └── Phase3Main.java
│   │
│   └── phase4_heap/
│       ├── HeapNode.java
│       ├── MinHeap.java
│       └── Phase4Main.java
│
└── README.md
````

---

## 3. قوانین طراحی مشترک در کل پروژه

- هر **ساختمان داده در یک پکیج جداگانه**
- هر **Node / Vertex / Member یک کلاس مستقل**
- هیچ داده‌ای نباید در:

  - ArrayList
  - HashMap
  - Set
  - PriorityQueue
    ذخیره شود
- ارتباط‌ها فقط از طریق **reference بین آبجکت‌ها**

---

## 4. فاز اول – مدیریت کانال‌های تأیید شده (AVL Tree)

### هدف فاز

مدیریت ChannelIDهای مجاز برای انتشار با استفاده از **درخت جستجوی دودویی خودمتوازن**.

---

### فایل‌ها و نقش آن‌ها

#### `AVLNode.java`

**مسئولیت:**

- نمایش یک رأس در درخت
- نگهداری:

  - ChannelID
  - ارتفاع
  - فرزند چپ و راست

**سطح طراحی:**

- فقط داده و سازنده
- بدون منطق درخت

---

#### `AVLTree.java`

**مسئولیت:**

- مدیریت کامل درخت AVL
- پیاده‌سازی منطق:

  - درج
  - حذف
  - جستجو
  - متوازن‌سازی

**متدهای طراحی‌شده:**

- insert
- delete
- search
- rotationها
- محاسبه height و balance
- display

---

#### `Phase1Main.java`

**مسئولیت:**

- اجرای سناریوهای تست
- گرفتن ورودی کاربر
- نمایش خروجی عملیات درخت

---

## 5. فاز دوم – پیشنهاد مسیر گوش دادن (Graph + Dijkstra)

### هدف فاز

محاسبه کوتاه‌ترین مسیر بین اپیزودها بر اساس شباهت موضوعی.

---

### فایل‌ها و نقش آن‌ها

#### `Vertex.java`

**مسئولیت:**

- نمایش یک اپیزود
- نگهداری ID اپیزود
- ارجاع به یال‌های متصل

---

#### `Edge.java`

**مسئولیت:**

- نمایش یال بین دو اپیزود
- نگهداری:

  - مقصد
  - وزن
  - یال بعدی

---

#### `Graph.java`

**مسئولیت:**

- نگهداری ساختار گراف
- مدیریت اتصال رأس‌ها
- ساخت گراف از ورودی

---

#### `Dijkstra.java`

**مسئولیت:**

- پیاده‌سازی دستی الگوریتم Dijkstra
- محاسبه کوتاه‌ترین مسیر
- چاپ مسیر و هزینه نهایی

---

#### `Phase2Main.java`

**مسئولیت:**

- ساخت گراف نمونه
- اجرای Dijkstra
- نمایش نتایج

---

## 6. فاز سوم – ساختار تیم تولید پادکست (Tree + BFS / DFS)

### هدف فاز

مدل‌سازی ساختار سلسله‌مراتبی تیم تولید.

---

### فایل‌ها و نقش آن‌ها

#### `TeamMember.java`

**مسئولیت:**

- نمایش یک عضو تیم
- نگهداری:

  - شناسه
  - لیست فرزندان (با reference)

---

#### `TeamTree.java`

**مسئولیت:**

- مدیریت درخت تیم
- پیاده‌سازی:

  - DFS
  - BFS
- افزودن و حذف اعضا
- نمایش ساختار تیم

---

#### `Phase3Main.java`

**مسئولیت:**

- تست سناریوهای تیم تولید
- جستجو و نمایش

---

## 7. فاز چهارم – صف انتشار اپیزودها (Min-Heap)

### هدف فاز

مدیریت صف انتشار بر اساس اولویت.

---

### فایل‌ها و نقش آن‌ها

#### `HeapNode.java`

**مسئولیت:**

- نگهداری:

  - EpisodeID
  - Priority

---

#### `MinHeap.java`

**مسئولیت:**

- پیاده‌سازی دستی Min-Heap
- پشتیبانی از:

  - insert
  - extract-min
  - delete
  - heap sort
  - display

---

#### `Phase4Main.java`

**مسئولیت:**

- تست صف انتشار
- اجرای heap sort
- نمایش ترتیب انتشار

---

## 8. ترتیب اجرایی پیشنهادی (Workflow)

1. ایجاد ساختار پوشه‌ها
2. نوشتن اسناد داخل `docs/`
3. طراحی کلاس‌های هر فاز (بدون کدنویسی)
4. پیاده‌سازی کامل فاز 1
5. تست و تثبیت فاز 1
6. پیاده‌سازی فازهای 2، 3 و 4 به ترتیب
7. مستندسازی نهایی
8. آماده‌سازی برای تحویل

---

## 9. خروجی نهایی پروژه

- کد جاوا تمیز و ماژولار
- رعایت کامل قوانین ساختمان داده
- مستندات کامل در پوشه docs
- پروژه قابل دفاع در ارائه شفاهی
